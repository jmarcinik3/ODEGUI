

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Function &mdash; Model 2021 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="Model 2021 documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Model
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <!-- Local TOC -->
                <div class="local-toc"></div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Model</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>Function</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for Function</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">KeysView</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">yaml</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ndarray</span>
<span class="kn">from</span> <span class="nn">pint</span> <span class="kn">import</span> <span class="n">Quantity</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Expr</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Piecewise</span> <span class="k">as</span> <span class="n">spPiecewise</span>
<span class="c1"># noinspection PyUnresolvedReferences</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">cosh</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">ln</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">solve</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">var</span>
<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">function</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.lambdify</span> <span class="kn">import</span> <span class="n">lambdify</span>

<span class="kn">import</span> <span class="nn">YML</span>
<span class="kn">from</span> <span class="nn">CustomErrors</span> <span class="kn">import</span> <span class="n">RecursiveTypeError</span>
<span class="kn">from</span> <span class="nn">macros</span> <span class="kn">import</span> <span class="n">unique</span>

<div class="viewcode-block" id="Model"><a class="viewcode-back" href="../Function.html#Function.Model">[docs]</a><span class="k">class</span> <span class="nc">Model</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    __Purpose__</span>
<span class="sd">        Store Function objects for given model</span>
<span class="sd">    __Attributes__</span>
<span class="sd">        functions [list of Function]: stored Function objects</span>
<span class="sd">        parameters [dict of metpy.Quantity]: stored parameter values and units</span>
<span class="sd">            key [str] is parameter name</span>
<span class="sd">            value [metpy.Quantity] contains value and unit</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">functions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Function</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">parameters</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addParameters</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">functions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addFunctions</span><span class="p">(</span><span class="n">functions</span><span class="p">)</span>
    
<div class="viewcode-block" id="Model.addParameters"><a class="viewcode-back" href="../Function.html#Function.Model.addParameters">[docs]</a>    <span class="k">def</span> <span class="nf">addParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantities</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set/add parameter(s) value and unit for model as Quantity.</span>
<span class="sd">        </span>
<span class="sd">        :param self: `~Function.Model` to set parameter(s) for</span>
<span class="sd">        :param quantities:</span>
<span class="sd">            Key is name of parameter.</span>
<span class="sd">            Value is quantity containing value and unit for parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">quantity</span> <span class="ow">in</span> <span class="n">quantities</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantity</span></div>
    
<div class="viewcode-block" id="Model.getParameterNames"><a class="viewcode-back" href="../Function.html#Function.Model.getParameterNames">[docs]</a>    <span class="k">def</span> <span class="nf">getParameterNames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get names of stored parameters in order added.</span>

<span class="sd">        :param self: :class:`~Function.Model` to retrieve names from</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>
    
<div class="viewcode-block" id="Model.getParameters"><a class="viewcode-back" href="../Function.html#Function.Model.getParameters">[docs]</a>    <span class="k">def</span> <span class="nf">getParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get parameter quantities stored in model.</span>
<span class="sd">        </span>
<span class="sd">        __Recursion Base__</span>
<span class="sd">            return single parameter: names [str]</span>

<span class="sd">        :param self: `~Function.Model` to retrieve parameter(s) from</span>
<span class="sd">        :param names: name(s) of parameter(s) to retrieve</span>
<span class="sd">        :returns: Quantity for parameter if :paramref:~Function.Model.getParameters.names` is str.</span>
<span class="sd">            List of quantities if :paramref:~Function.Model.getParameters.names` is list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">names</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParameters</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParameters</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">}</span>
        <span class="k">elif</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParameters</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getParameterNames</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecursiveTypeError</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">])</span></div>
    
<div class="viewcode-block" id="Model.getVariables"><a class="viewcode-back" href="../Function.html#Function.Model.getVariables">[docs]</a>    <span class="k">def</span> <span class="nf">getVariables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">functions</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Function</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Function</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get variable(s) associated with function(s) in model</span>
<span class="sd">        __Recursion Base__</span>
<span class="sd">            return variable associated with single function: functions [Function]</span>

<span class="sd">        :param self: `~Function.Model` to retrieve function objects from</span>
<span class="sd">        :param functions: function to retrieve variables from</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">functions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">functions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFunctions</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">functions</span><span class="o">.</span><span class="n">getVariables</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">:</span>
                <span class="n">variables</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getVariables</span><span class="p">(</span><span class="n">functions</span><span class="o">=</span><span class="n">function</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">unique</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecursiveTypeError</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="n">Function</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Model.addFunctions"><a class="viewcode-back" href="../Function.html#Function.Model.addFunctions">[docs]</a>    <span class="k">def</span> <span class="nf">addFunctions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">functions</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Function</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Function</span><span class="p">]],</span> <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add Function object(s) to model.</span>
<span class="sd">        Set self as model for Function object(s).</span>

<span class="sd">        :param self: `~Function.Model` to add function to</span>
<span class="sd">        :param functions: function(s) to add to model</span>
<span class="sd">        :param overwrite: set True to overwrite function if already in model.</span>
<span class="sd">            Set False to raise error for duplicate function name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">functions</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFunctions</span><span class="p">():</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">functions</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFunctionNames</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Overwriting </span><span class="si">{</span><span class="n">name</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">functions</span><span class="o">.</span><span class="n">getForm</span><span class="p">()</span><span class="si">:}</span><span class="s2"> in model&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Function name </span><span class="si">{</span><span class="n">name</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2"> already used in Model instance&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">functions</span><span class="o">.</span><span class="n">getModel</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">functions</span><span class="o">.</span><span class="n">setModel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">functions</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addFunctions</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecursiveTypeError</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="n">Function</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Model.loadFunctionsFromFiles"><a class="viewcode-back" href="../Function.html#Function.Model.loadFunctionsFromFiles">[docs]</a>    <span class="k">def</span> <span class="nf">loadFunctionsFromFiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function_ymls</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Add functions to model by parsing through YML file</span>

<span class="sd">        :param self: `~Function.Model` to add function(s) to</span>
<span class="sd">        :param function_ymls: name of YML file to retrieve function info from</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function_ymls</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">function_ymls</span> <span class="o">=</span> <span class="p">[</span><span class="n">function_ymls</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">function_yml</span> <span class="ow">in</span> <span class="n">function_ymls</span><span class="p">:</span>
            <span class="n">file</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">function_yml</span><span class="p">),</span> <span class="n">Loader</span><span class="o">=</span><span class="n">yaml</span><span class="o">.</span><span class="n">Loader</span><span class="p">)</span>
            
            <span class="n">generateFunctionsFromFile</span><span class="p">(</span><span class="n">function_yml</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Model.loadParametersFromFile"><a class="viewcode-back" href="../Function.html#Function.Model.loadParametersFromFile">[docs]</a>    <span class="k">def</span> <span class="nf">loadParametersFromFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters_yml</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Add parameters to model by parsing through YML file</span>

<span class="sd">        :param self: `~Function.Model` to add function(s) to</span>
<span class="sd">        :param parameters_yml: name of YML file to retrieve parameter info from</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">YML</span><span class="o">.</span><span class="n">readParameters</span><span class="p">(</span><span class="n">parameters_yml</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addParameters</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Model.saveParametersToFile"><a class="viewcode-back" href="../Function.html#Function.Model.saveParametersToFile">[docs]</a>    <span class="k">def</span> <span class="nf">saveParametersToFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save parameters stored in model into YML file for future retrieval.</span>
<span class="sd">        </span>
<span class="sd">        :param self: :class:`~Function.Model` to retrieve parameters from</span>
<span class="sd">        :param filename: name of file to save parameters into</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParameters</span><span class="p">()</span>
        <span class="n">parameters_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">quantity</span><span class="o">.</span><span class="n">magnitude</span><span class="p">,</span>
                <span class="s2">&quot;unit&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">quantity</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">quantity</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">yaml</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">parameters_dict</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Model.saveTimeEvolutionTypesToFile"><a class="viewcode-back" href="../Function.html#Function.Model.saveTimeEvolutionTypesToFile">[docs]</a>    <span class="k">def</span> <span class="nf">saveTimeEvolutionTypesToFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">derivatives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDerivatives</span><span class="p">()</span>
        <span class="n">time_evolution_types</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">derivative</span><span class="o">.</span><span class="n">getVariable</span><span class="p">()):</span> <span class="n">derivative</span><span class="o">.</span><span class="n">getTimeEvolutionType</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">derivative</span> <span class="ow">in</span> <span class="n">derivatives</span>
        <span class="p">}</span>
        <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">yaml</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">time_evolution_types</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Model.getFunctionNames"><a class="viewcode-back" href="../Function.html#Function.Model.getFunctionNames">[docs]</a>    <span class="k">def</span> <span class="nf">getFunctionNames</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get names of stored functions in order added.</span>

<span class="sd">        :param self: :class:`~Function.Model` to retrieve names from</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>
    
<div class="viewcode-block" id="Model.getFunctions"><a class="viewcode-back" href="../Function.html#Function.Model.getFunctions">[docs]</a>    <span class="k">def</span> <span class="nf">getFunctions</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">filter_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Function</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Function</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Function</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get functions stored in model.</span>
<span class="sd">        </span>
<span class="sd">        __Recursion Base__</span>
<span class="sd">            return single function if compatible with filter type: names [None]</span>

<span class="sd">        :param self: :class:`~Function.Model` to retrieve function(s) from</span>
<span class="sd">        :param names: name(s) of function(s) to retrieve</span>
<span class="sd">        :param filter_type: only retrieve function(s) of this class, acts as a filter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">names</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">filter_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">filter_type</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">function</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;names input must correspond to </span><span class="si">{</span><span class="n">filter_type</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">functions</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">getFunctions</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">filter_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">functions</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">function</span> <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">functions</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">filter_type</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFunctions</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getFunctionNames</span><span class="p">(),</span> <span class="n">filter_type</span><span class="o">=</span><span class="n">filter_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecursiveTypeError</span><span class="p">(</span><span class="n">names</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Model.getDerivatives"><a class="viewcode-back" href="../Function.html#Function.Model.getDerivatives">[docs]</a>    <span class="k">def</span> <span class="nf">getDerivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_evolution_types</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Derivative</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get stored derivatives of given time-evolution type(s)</span>
<span class="sd">        __Recursion Base__</span>
<span class="sd">            get derivatives of single time-evolution type: time_evolution_types [str]</span>
<span class="sd">            get all derivatives: time_evolution_types [None]</span>

<span class="sd">        :param self: `~Function.Model` to retrieve derivative(s) from</span>
<span class="sd">        :param time_evolution_types: only retrieve derivatives of this type(s), acts as a filter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_evolution_types</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">filtered_derivatives</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">derivative</span>
                <span class="k">for</span> <span class="n">derivative</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFunctions</span><span class="p">(</span><span class="n">filter_type</span><span class="o">=</span><span class="n">Derivative</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">derivative</span><span class="o">.</span><span class="n">getTimeEvolutionType</span><span class="p">()</span> <span class="o">==</span> <span class="n">time_evolution_types</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="n">filtered_derivatives</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_evolution_types</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">derivatives</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">derivative</span>
                <span class="k">for</span> <span class="n">time_evolution_type</span> <span class="ow">in</span> <span class="n">time_evolution_types</span>
                <span class="k">for</span> <span class="n">derivative</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDerivatives</span><span class="p">(</span><span class="n">time_evolution_types</span><span class="o">=</span><span class="n">time_evolution_type</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="n">derivatives</span>
        <span class="k">elif</span> <span class="n">time_evolution_types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># noinspection PyTypeChecker</span>
            <span class="n">derivatives</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Derivative</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFunctions</span><span class="p">(</span><span class="n">filter_type</span><span class="o">=</span><span class="n">Derivative</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">derivatives</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecursiveTypeError</span><span class="p">(</span><span class="n">time_evolution_types</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Model.getEquilibriumSolutions"><a class="viewcode-back" href="../Function.html#Function.Model.getEquilibriumSolutions">[docs]</a>    <span class="k">def</span> <span class="nf">getEquilibriumSolutions</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">substitute_parameters</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">skip_parameters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">substitute_constants</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">substitute_functions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get substitutions to substitute equilibrium variables into non-equilibrium derivatives</span>
<span class="sd">        __Return__</span>
<span class="sd">            dict:</span>
<span class="sd">                key [sympy.Symbol] is variable to substitute into</span>
<span class="sd">                value [sympy.Expr] is expression to substitute into variable</span>

<span class="sd">        :param self: `~Function.Model` to solve for equilibrium solution(s) in</span>
<span class="sd">        :param names: name(s) of function(s) to solve for simulatenous equilibrium of</span>
<span class="sd">        :param substitute_parameters: set True to substitute numerical values in for all parameters.</span>
<span class="sd">            Set false otherwise</span>
<span class="sd">        :param skip_parameters: name(s) of parameter(s) to skip substitution for.</span>
<span class="sd">            Only called if :paramref:`~Function.Model.getEquilibriumSolutions.substitute_parameters` is set True.</span>
<span class="sd">        :param substitute_constants: set True to substitute numerical values in for all constant derivative.</span>
<span class="sd">            Set False to leave them as symbolic variables.</span>
<span class="sd">        :param substitute_functions: set True to substitute corresponding functions in for all function-type derivatives.</span>
<span class="sd">            Set False to leave them as symbolic variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">skip_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skip_parameters</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">equilibria</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFunctions</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">)</span> <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">equilibria</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;names must correspond to Derivative stored in Model&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">equilibria</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDerivatives</span><span class="p">(</span><span class="n">time_evolution_types</span><span class="o">=</span><span class="s2">&quot;Equilibrium&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecursiveTypeError</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        
        <span class="n">equilibrium_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">equilibria</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">equilibrium_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="k">elif</span> <span class="n">equilibrium_count</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">equilibrium_variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">equilibrium</span><span class="o">.</span><span class="n">getVariable</span><span class="p">()</span> <span class="k">for</span> <span class="n">equilibrium</span> <span class="ow">in</span> <span class="n">equilibria</span><span class="p">]</span>
            <span class="n">equilibrium_derivatives</span> <span class="o">=</span> <span class="p">[</span><span class="n">equilibrium</span><span class="o">.</span><span class="n">getForm</span><span class="p">(</span><span class="n">generations</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">equilibrium</span> <span class="ow">in</span> <span class="n">equilibria</span><span class="p">]</span>
            
            <span class="n">bk_probs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;pC0 pC1 pC2 pO2 pO3&quot;</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">bk_probs</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">equilibrium_variables</span><span class="p">)):</span>
                <span class="n">equilibrium_derivatives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">bk_probs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">solutions</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">equilibrium_derivatives</span><span class="p">,</span> <span class="n">equilibrium_variables</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">substitute_functions</span><span class="p">:</span>
                <span class="n">function_substitutions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFunctionSubstitutions</span><span class="p">(</span>
                    <span class="n">substitute_parameters</span><span class="o">=</span><span class="n">substitute_parameters</span><span class="p">,</span>
                    <span class="n">skip_parameters</span><span class="o">=</span><span class="n">skip_parameters</span><span class="p">,</span>
                    <span class="n">substitute_constants</span><span class="o">=</span><span class="n">substitute_constants</span>
                <span class="p">)</span>
                <span class="n">solutions</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">variable</span><span class="p">:</span> <span class="n">solution</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">function_substitutions</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">solution</span> <span class="ow">in</span> <span class="n">solutions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>
            <span class="k">if</span> <span class="n">substitute_parameters</span><span class="p">:</span>
                <span class="n">parameter_names</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">parameter_names_extend</span> <span class="o">=</span> <span class="n">parameter_names</span><span class="o">.</span><span class="n">extend</span>
                <span class="k">for</span> <span class="n">equilibrium</span> <span class="ow">in</span> <span class="n">equilibria</span><span class="p">:</span>
                    <span class="n">new_parameter_names</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">parameter</span>
                        <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">equilibrium</span><span class="o">.</span><span class="n">getParameters</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">parameter</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">skip_parameters</span>
                    <span class="p">]</span>
                    <span class="n">parameter_names_extend</span><span class="p">(</span><span class="n">new_parameter_names</span><span class="p">)</span>
                <span class="n">parameter_names</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">parameter_names</span><span class="p">)</span>
                <span class="n">parameter_substitutions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParameterSubstitutions</span><span class="p">(</span><span class="n">parameter_names</span><span class="p">)</span>
                
                <span class="n">solutions</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">variable</span><span class="p">:</span> <span class="n">solution</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">parameter_substitutions</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">solution</span> <span class="ow">in</span> <span class="n">solutions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>
            <span class="k">if</span> <span class="n">substitute_constants</span><span class="p">:</span>
                <span class="n">constant_substitutions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getConstantSubstitutions</span><span class="p">()</span>
                <span class="n">solutions</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">variable</span><span class="p">:</span> <span class="n">solution</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">constant_substitutions</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">solution</span> <span class="ow">in</span> <span class="n">solutions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>
            <span class="k">return</span> <span class="n">solutions</span></div>
    
<div class="viewcode-block" id="Model.getEquilibriumFunction"><a class="viewcode-back" href="../Function.html#Function.Model.getEquilibriumFunction">[docs]</a>    <span class="k">def</span> <span class="nf">getEquilibriumFunction</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">substitute_parameters</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">skip_parameters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">substitute_constants</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">substitute_functions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get equilibrium function corresponding to derivative</span>

<span class="sd">        :param self: `~Function.Model` to solve for equilibrium solution in</span>
<span class="sd">        :param name: name of variable to retrieve equilibrium expression of</span>
<span class="sd">        :param substitute_parameters: set True to substitute numerical values in for all parameters.</span>
<span class="sd">            Set false otherwise</span>
<span class="sd">        :param skip_parameters: name(s) of parameter(s) to skip substitution for.</span>
<span class="sd">            Only called if :paramref:`~Function.Model.getEquilibriumSolutions.substitute_parameters` is set True.</span>
<span class="sd">        :param substitute_constants: set True to substitute numerical values in for all constant derivative.</span>
<span class="sd">            Set False to leave them as symbolic variables.</span>
<span class="sd">        :param substitute_functions: set True to substitute corresponding functions in for all function-type derivatives.</span>
<span class="sd">            Set False to leave them as symbolic variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">equilibria</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getEquilibriumSolutions</span><span class="p">(</span>
            <span class="n">substitute_parameters</span><span class="o">=</span><span class="n">substitute_parameters</span><span class="p">,</span>
            <span class="n">skip_parameters</span><span class="o">=</span><span class="n">skip_parameters</span><span class="p">,</span>
            <span class="n">substitute_constants</span><span class="o">=</span><span class="n">substitute_constants</span><span class="p">,</span>
            <span class="n">substitute_functions</span><span class="o">=</span><span class="n">substitute_functions</span>
        <span class="p">)</span>
        <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDerivativesFromVariableNames</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="n">equilibrium</span> <span class="o">=</span> <span class="n">equilibria</span><span class="p">[</span><span class="n">function</span><span class="o">.</span><span class="n">getVariable</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">equilibrium</span></div>
    
<div class="viewcode-block" id="Model.getFunctionSubstitutions"><a class="viewcode-back" href="../Function.html#Function.Model.getFunctionSubstitutions">[docs]</a>    <span class="k">def</span> <span class="nf">getFunctionSubstitutions</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">substitute_parameters</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">skip_parameters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">substitute_constants</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param self: `~Function.Model` to retrieve functions from</span>
<span class="sd">        :param names: name(s) of variable(s) to retrieve function for</span>
<span class="sd">        :param substitute_parameters: set True to substitute numerical values in for all parameters.</span>
<span class="sd">            Set False to leave them as symbolic variables.</span>
<span class="sd">        :param skip_parameters: name(s) of parameter(s) to skip substitution for.</span>
<span class="sd">            Only called if :paramref:`~Function.Model.getFunctionSubstitutions.substitute_parameters` is set True.</span>
<span class="sd">        :param substitute_constants: set True to substitute numerical values in for all constant derivative.</span>
<span class="sd">            Set False to leave them as symbolic variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">skip_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skip_parameters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDerivativeVariables</span><span class="p">(</span><span class="n">time_evolution_types</span><span class="o">=</span><span class="s2">&quot;Function&quot;</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
        
        <span class="n">variable_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">variable_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="k">elif</span> <span class="n">variable_count</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">functions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFunctions</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>
            <span class="n">forms</span> <span class="o">=</span> <span class="p">[</span><span class="n">function</span><span class="o">.</span><span class="n">getForm</span><span class="p">(</span><span class="n">generations</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">]</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">substitute_parameters</span><span class="p">:</span>
                <span class="n">parameter_names</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">parameter_names_extend</span> <span class="o">=</span> <span class="n">parameter_names</span><span class="o">.</span><span class="n">extend</span>
                
                <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">:</span>
                    <span class="n">new_parameter_names</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">parameter_name</span>
                        <span class="k">for</span> <span class="n">parameter_name</span> <span class="ow">in</span> <span class="n">function</span><span class="o">.</span><span class="n">getParameters</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">parameter_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">skip_parameters</span>
                    <span class="p">]</span>
                    <span class="n">parameter_names_extend</span><span class="p">(</span><span class="n">new_parameter_names</span><span class="p">)</span>
                <span class="n">parameter_names</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">parameter_names</span><span class="p">)</span>
                
                <span class="n">parameter_substitutions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParameterSubstitutions</span><span class="p">(</span><span class="n">parameter_names</span><span class="p">)</span>
                <span class="n">forms</span> <span class="o">=</span> <span class="p">[</span><span class="n">form</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">parameter_substitutions</span><span class="p">)</span> <span class="k">for</span> <span class="n">form</span> <span class="ow">in</span> <span class="n">forms</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">substitute_constants</span><span class="p">:</span>
                <span class="n">constant_substitutions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getConstantSubstitutions</span><span class="p">()</span>
                <span class="n">forms</span> <span class="o">=</span> <span class="p">[</span><span class="n">form</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">constant_substitutions</span><span class="p">)</span> <span class="k">for</span> <span class="n">form</span> <span class="ow">in</span> <span class="n">forms</span><span class="p">]</span>
            
            <span class="n">substitutions</span> <span class="o">=</span> <span class="p">{</span><span class="n">variables</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">forms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">variable_count</span><span class="p">)}</span>
            <span class="k">return</span> <span class="n">substitutions</span></div>
    
<div class="viewcode-block" id="Model.getConstantSubstitutions"><a class="viewcode-back" href="../Function.html#Function.Model.getConstantSubstitutions">[docs]</a>    <span class="k">def</span> <span class="nf">getConstantSubstitutions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get substitutions to substitute constant intitial condition into given variable(s)</span>
<span class="sd">        __Return__</span>
<span class="sd">            dict:</span>
<span class="sd">                key [sympy.Symbol] is variable to substitute into</span>
<span class="sd">                value [sympy.Expr] is constant to substitute into variable</span>

<span class="sd">        :param self: `~Function.Model` to retrieve constant derivative(s) from</span>
<span class="sd">        :param names: name(s) of constant derivative(s) to substitute numerical constants in for</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">constant_functions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getFunctions</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">constant_functions</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;names must correspond to Derivative stored in Model&quot;</span>
                    <span class="p">)</span>
        <span class="k">elif</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">constant_functions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDerivatives</span><span class="p">(</span><span class="n">time_evolution_types</span><span class="o">=</span><span class="s2">&quot;Constant&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecursiveTypeError</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="n">constant_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">constant_functions</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">constant_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="k">elif</span> <span class="n">constant_count</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">substitutions</span> <span class="o">=</span> <span class="p">{</span><span class="n">function</span><span class="o">.</span><span class="n">getVariable</span><span class="p">():</span> <span class="n">function</span><span class="o">.</span><span class="n">getInitialCondition</span><span class="p">()</span> <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">constant_functions</span><span class="p">}</span>
            <span class="k">return</span> <span class="n">substitutions</span></div>
    
<div class="viewcode-block" id="Model.getParameterSubstitutions"><a class="viewcode-back" href="../Function.html#Function.Model.getParameterSubstitutions">[docs]</a>    <span class="k">def</span> <span class="nf">getParameterSubstitutions</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">skip_parameters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Substitute parameters into function from model.</span>

<span class="sd">        :param names: name(s) of parameter to include in substitutions.</span>
<span class="sd">            Defaults to all parameters in model.</span>
<span class="sd">        :param skip_parameters: name(s) of parameter(s) to skip substitution for</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">skip_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skip_parameters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">quantities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParameters</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">quantities</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        
        <span class="n">substitutions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">Symbol</span><span class="p">(</span><span class="n">parameter_name</span><span class="p">):</span> <span class="n">quantities</span><span class="p">[</span><span class="n">parameter_name</span><span class="p">]</span><span class="o">.</span><span class="n">to_base_units</span><span class="p">()</span><span class="o">.</span><span class="n">magnitude</span>
            <span class="k">for</span> <span class="n">parameter_name</span> <span class="ow">in</span> <span class="n">names</span>
            <span class="k">if</span> <span class="n">parameter_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">skip_parameters</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">substitutions</span></div>
    
<div class="viewcode-block" id="Model.getDerivativeVector"><a class="viewcode-back" href="../Function.html#Function.Model.getDerivativeVector">[docs]</a>    <span class="k">def</span> <span class="nf">getDerivativeVector</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">expanded</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">substitute_parameters</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">skip_parameters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">substitute_equilibria</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">substitute_constants</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">substitute_functions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">lambdified</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Expr</span><span class="p">],</span> <span class="n">function</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get derivative vector corresponding to derivatives in :class:`~Function.Model`</span>

<span class="sd">        :param self: `~Function.Model` to retrieve derivative(s) from</span>
<span class="sd">        :param names: name(s) of variable(s) ordered in same order derivatives will be returned</span>
<span class="sd">        :param expanded: set True to get expanded expression for derivative, i.e. substitute all subexpressions into derivative expression.</span>
<span class="sd">            Set False to leave subexpressions as symbolic variables.</span>
<span class="sd">        :param substitute_parameters: set True to substitute numerical values in for all parameters.</span>
<span class="sd">            Set false otherwise</span>
<span class="sd">        :param skip_parameters: name(s) of parameter(s) to skip substitution for.</span>
<span class="sd">            Only called if :paramref:`~Function.Model.getDerivativeVector.substitute_parameters` is set True.</span>
<span class="sd">        :param substitute_equilibria: set True to substitute equilibrium expressions in for variables in equilibrium.</span>
<span class="sd">            Set False to leave them as symbolic variables.</span>
<span class="sd">        :param substitute_constants: set True to substitute numerical values in for all constant derivative.</span>
<span class="sd">            Set False to leave them as symbolic variables.</span>
<span class="sd">        :param substitute_functions: set True to substitute corresponding functions in for all function-type derivatives.</span>
<span class="sd">            Set False to leave them as symbolic variables.</span>
<span class="sd">        :param lambdified: set True to return derivative vector as lambda function handle.</span>
<span class="sd">            Set False to return symbolic derivative vector</span>
<span class="sd">        :returns: vector of derivatives.</span>
<span class="sd">            Uses derivatives in :class:`~Function.Model` to determine derivatives.</span>
<span class="sd">            Returned as list of symbolic expressions if :paramref:`~Function.Model.getDerivativeVector.lambdified` is set to True.</span>
<span class="sd">            Returned as lambda function handle if :paramref:`~Function.Model.getDerivativeVector.lambdified` is set to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">skip_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skip_parameters</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">variable_substitutions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">substitute_equilibria</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;substitute_parameters&quot;</span><span class="p">:</span> <span class="n">substitute_parameters</span><span class="p">,</span>
                <span class="s2">&quot;substitute_constants&quot;</span><span class="p">:</span> <span class="n">substitute_constants</span><span class="p">,</span>
                <span class="s2">&quot;skip_parameters&quot;</span><span class="p">:</span> <span class="n">skip_parameters</span>
            <span class="p">}</span>
            <span class="n">equilibrium_solutions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getEquilibriumSolutions</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">variable_substitutions</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">equilibrium_solutions</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">substitute_constants</span><span class="p">:</span>
            <span class="n">variable_substitutions</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getConstantSubstitutions</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">substitute_functions</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;substitute_parameters&quot;</span><span class="p">:</span> <span class="n">substitute_parameters</span><span class="p">,</span>
                <span class="s2">&quot;substitute_constants&quot;</span><span class="p">:</span> <span class="n">substitute_constants</span><span class="p">,</span>
                <span class="s2">&quot;skip_parameters&quot;</span><span class="p">:</span> <span class="n">skip_parameters</span>
            <span class="p">}</span>
            <span class="n">variable_substitutions</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getFunctionSubstitutions</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        
        <span class="n">parameter_substitutions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">substitute_parameters</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;skip_parameters&quot;</span><span class="p">:</span> <span class="n">skip_parameters</span>
            <span class="p">}</span>
            <span class="n">parameter_substitutions</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getParameterSubstitutions</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">temporal_derivatives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDerivatives</span><span class="p">(</span><span class="n">time_evolution_types</span><span class="o">=</span><span class="s2">&quot;Temporal&quot;</span><span class="p">)</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">derivative</span><span class="o">.</span><span class="n">getVariable</span><span class="p">())</span> <span class="k">for</span> <span class="n">derivative</span> <span class="ow">in</span> <span class="n">temporal_derivatives</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">temporal_derivatives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDerivativesFromVariableNames</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>
        
        <span class="n">derivative_vector</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">derivative</span> <span class="ow">in</span> <span class="n">temporal_derivatives</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">expanded</span><span class="p">:</span>
                <span class="n">form</span> <span class="o">=</span> <span class="n">derivative</span><span class="o">.</span><span class="n">getForm</span><span class="p">(</span><span class="n">generations</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">form</span> <span class="o">=</span> <span class="n">derivative</span><span class="o">.</span><span class="n">getForm</span><span class="p">()</span>
            
            <span class="n">variable_substitution</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">variable</span><span class="p">:</span> <span class="n">substitution</span>
                <span class="k">for</span> <span class="n">variable</span><span class="p">,</span> <span class="n">substitution</span> <span class="ow">in</span> <span class="n">variable_substitutions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">derivative</span><span class="o">.</span><span class="n">getVariables</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="n">parameter_substitution</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">parameter</span><span class="p">:</span> <span class="n">value</span>
                <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">parameter_substitutions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">derivative</span><span class="o">.</span><span class="n">getParameters</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="n">form</span> <span class="o">=</span> <span class="n">form</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="o">**</span><span class="n">variable_substitution</span><span class="p">,</span> <span class="o">**</span><span class="n">parameter_substitution</span><span class="p">})</span>
            
            <span class="n">derivative_vector</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">lambdified</span><span class="p">:</span>
            <span class="n">derivative_vector</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">((</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">names</span><span class="p">)),</span> <span class="n">derivative_vector</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">substitute_equilibria</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">derivative_vector</span><span class="p">,</span> <span class="n">equilibrium_solutions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">derivative_vector</span></div>
    
<div class="viewcode-block" id="Model.getInitialValues"><a class="viewcode-back" href="../Function.html#Function.Model.getInitialValues">[docs]</a>    <span class="k">def</span> <span class="nf">getInitialValues</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">return_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">,</span>
            <span class="n">initial_values</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">ndarray</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get initial values for variables in model.</span>
<span class="sd">        </span>
<span class="sd">        :param self: `~Function.Model` to retrieve derivatives from</span>
<span class="sd">        :param names: name(s) of variables to retrieve values for</span>
<span class="sd">        :param return_type: class type for output.</span>
<span class="sd">            Must be dict, list, or ndarray.</span>
<span class="sd">            Only called if names is list.</span>
<span class="sd">        :param initial_values: dictionary of initial values if already known.</span>
<span class="sd">            Key is symbol for variable.</span>
<span class="sd">            Value is float for initial value.</span>
<span class="sd">        :returns: Initial values for desired variables.</span>
<span class="sd">            Dictionary of initial values if return_type is dict; key is symbol for variable, value if float for initial value.</span>
<span class="sd">            List of floats if return_type is list.</span>
<span class="sd">            ndarray of float if return_type is ndarray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">initial_values</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">derivative</span><span class="o">.</span><span class="n">getVariable</span><span class="p">():</span> <span class="n">initial_value</span>
            <span class="k">for</span> <span class="n">derivative</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDerivatives</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">((</span><span class="n">initial_value</span> <span class="o">:=</span> <span class="n">derivative</span><span class="o">.</span><span class="n">getInitialCondition</span><span class="p">()),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="n">initial_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">derivatives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDerivatives</span><span class="p">()</span>
            
            <span class="n">initial_constant_substitutions</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">derivative</span><span class="o">.</span><span class="n">getVariable</span><span class="p">():</span> <span class="n">initial_value</span>
                <span class="k">for</span> <span class="n">derivative</span> <span class="ow">in</span> <span class="n">derivatives</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">((</span><span class="n">initial_value</span> <span class="o">:=</span> <span class="n">derivative</span><span class="o">.</span><span class="n">getInitialCondition</span><span class="p">()),</span> <span class="nb">float</span><span class="p">)</span>
            <span class="p">}</span>
            
            <span class="n">substitutions</span> <span class="o">=</span> <span class="p">{</span>
                <span class="o">**</span><span class="n">initial_constant_substitutions</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">getConstantSubstitutions</span><span class="p">(),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">getParameterSubstitutions</span><span class="p">()</span>
            <span class="p">}</span>
            
            <span class="n">equilibrium_equations</span><span class="p">,</span> <span class="n">equilibrium_variables</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="n">equations_append</span><span class="p">,</span> <span class="n">variables_append</span> <span class="o">=</span> <span class="n">equilibrium_equations</span><span class="o">.</span><span class="n">append</span><span class="p">,</span> <span class="n">equilibrium_variables</span><span class="o">.</span><span class="n">append</span>
            <span class="k">for</span> <span class="n">derivative</span> <span class="ow">in</span> <span class="n">derivatives</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">derivative</span><span class="o">.</span><span class="n">getInitialCondition</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;Equilibrium&quot;</span><span class="p">:</span>
                    <span class="n">equations_append</span><span class="p">(</span><span class="n">derivative</span><span class="o">.</span><span class="n">getForm</span><span class="p">(</span><span class="n">generations</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">substitutions</span><span class="p">))</span>
                    <span class="n">variables_append</span><span class="p">(</span><span class="n">derivative</span><span class="o">.</span><span class="n">getVariable</span><span class="p">())</span>
            
            <span class="n">variable_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">equilibrium_variables</span><span class="p">)</span>
            <span class="n">equations_lambda</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">((</span><span class="nb">tuple</span><span class="p">(</span><span class="n">equilibrium_variables</span><span class="p">),),</span> <span class="n">equilibrium_equations</span><span class="p">)</span>
            <span class="n">initial_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">variable_count</span><span class="p">)</span>
            <span class="n">roots</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">root</span><span class="p">(</span><span class="n">equations_lambda</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">)</span>
            <span class="n">solutions</span> <span class="o">=</span> <span class="p">{</span><span class="n">equilibrium_variables</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">roots</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">variable_count</span><span class="p">)}</span>
            
            <span class="n">initial_values</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">initial_constant_substitutions</span><span class="p">,</span> <span class="o">**</span><span class="n">solutions</span><span class="p">}</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="n">initial_values</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">initial_values</span><span class="p">[</span><span class="n">Symbol</span><span class="p">(</span><span class="n">names</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">initial_values</span><span class="p">[</span><span class="n">names</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">initial_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">name</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">getInitialValues</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">initial_values</span><span class="o">=</span><span class="n">initial_values</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">return_type</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">initial_value</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">return_type</span> <span class="o">==</span> <span class="n">ndarray</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">initial_value</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">return_type</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="p">):</span> <span class="n">initial_value</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;return_type must be list, ndarray, or dict&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecursiveTypeError</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">])</span></div>
    
<div class="viewcode-block" id="Model.getDerivativeVariables"><a class="viewcode-back" href="../Function.html#Function.Model.getDerivativeVariables">[docs]</a>    <span class="k">def</span> <span class="nf">getDerivativeVariables</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">time_evolution_types</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">return_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Symbol</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get variables stored in model in same order as derivatives</span>
<span class="sd">        </span>
<span class="sd">        __Recursion Base__</span>
<span class="sd">            get symbolic variable associated with single derivative: names [str]</span>

<span class="sd">        :param self: `~Function.Model` to retrieve derivative variable(s) from</span>
<span class="sd">        :param time_evolution_types: only retrieve derivatives of this type(s), acts as a filter</span>
<span class="sd">        :param return_type: class type to return elements in list output as</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_evolution_types</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">derivatives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDerivatives</span><span class="p">(</span><span class="n">time_evolution_types</span><span class="o">=</span><span class="n">time_evolution_types</span><span class="p">)</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">derivative</span><span class="o">.</span><span class="n">getVariable</span><span class="p">()</span> <span class="k">for</span> <span class="n">derivative</span> <span class="ow">in</span> <span class="n">derivatives</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_evolution_types</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">getDerivativeVariables</span><span class="p">(</span><span class="n">time_evolution_types</span><span class="o">=</span><span class="n">time_evolution_type</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">time_evolution_type</span> <span class="ow">in</span> <span class="n">time_evolution_types</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="n">time_evolution_types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">derivatives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDerivatives</span><span class="p">()</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span><span class="n">derivative</span><span class="o">.</span><span class="n">getVariable</span><span class="p">()</span> <span class="k">for</span> <span class="n">derivative</span> <span class="ow">in</span> <span class="n">derivatives</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecursiveTypeError</span><span class="p">(</span><span class="n">time_evolution_types</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">return_type</span> <span class="o">==</span> <span class="n">Symbol</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">variables</span>
        <span class="k">elif</span> <span class="n">return_type</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;return_type must be Symbol or str&quot;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Model.getDerivativesFromVariableNames"><a class="viewcode-back" href="../Function.html#Function.Model.getDerivativesFromVariableNames">[docs]</a>    <span class="k">def</span> <span class="nf">getDerivativesFromVariableNames</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">]]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Derivative</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Derivative</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get derivative corresponding to variable name.</span>

<span class="sd">        :param self: :class:`~Function.Model` to retrieve derivative(s) from</span>
<span class="sd">        :param names: name(s) of variable(s) associated with derivative(s)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)):</span>
            <span class="n">derivatives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDerivatives</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">derivative</span> <span class="ow">in</span> <span class="n">derivatives</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">derivative</span><span class="o">.</span><span class="n">getVariable</span><span class="p">(</span><span class="n">return_type</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">derivative</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;names input must correspond to some Derivative stored in Model&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">getDerivativesFromVariableNames</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">RecursiveTypeError</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">])</span></div></div>

<div class="viewcode-block" id="Parent"><a class="viewcode-back" href="../Function.html#Function.Parent">[docs]</a><span class="k">class</span> <span class="nc">Parent</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    __Purpose__</span>
<span class="sd">        Properties for Function related to being a parent function to another function</span>
<span class="sd">    __Attributes__</span>
<span class="sd">        children [list of Function]: collection of children associated with function</span>
<span class="sd">        instance_arguments [list of dict list of sympy.Symbol]: arguments which parent function inputs into child function</span>
<span class="sd">            first list index is index of stored child function</span>
<span class="sd">            dictionary key is argument species</span>
<span class="sd">            second list index is index of individual argument sent to child function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instance_arguments</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="n">Child</span><span class="p">):</span>
                <span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="n">children</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addChildren</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
    
<div class="viewcode-block" id="Parent.addChildren"><a class="viewcode-back" href="../Function.html#Function.Parent.addChildren">[docs]</a>    <span class="k">def</span> <span class="nf">addChildren</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]]])</span> <span class="o">-&gt;</span>\
            <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add information to reference children functions of parent.</span>

<span class="sd">        :param self: :class:`~Function.Parent` to add info into</span>
<span class="sd">        :param children: dictionary of information to reference children.</span>
<span class="sd">            Key is name of child.</span>
<span class="sd">            Value is dictionary to pass into :paramref:`~Function.Parent.addChild.arguments`</span>
<span class="sd">        :returns: Dictionary of information to reference children.</span>
<span class="sd">            Key is name of child.</span>
<span class="sd">            Value is dictionary of information output from :meth:`~Function.Parent.addChild`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">addChild</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">arguments</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">arguments</span> <span class="ow">in</span> <span class="n">children</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>
    
<div class="viewcode-block" id="Parent.addChild"><a class="viewcode-back" href="../Function.html#Function.Parent.addChild">[docs]</a>    <span class="k">def</span> <span class="nf">addChild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">arguments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add information to reference child function of parent.</span>

<span class="sd">        :param self: :class:`~Function.Parent` to add info into</span>
<span class="sd">        :param name: name of child to add into parent</span>
<span class="sd">        :param arguments: dictionary of information to reference child.</span>
<span class="sd">            Key is species of instance argument.</span>
<span class="sd">            Value is symbol(s) for this species of argument.</span>
<span class="sd">        :returns: Dictionary of information to reference child.</span>
<span class="sd">            Key is species of instance argument from parent.</span>
<span class="sd">            Value is symbol(s) for this species of argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_child</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">specie</span><span class="p">:</span> <span class="p">[</span><span class="n">instance_argument</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">((</span><span class="n">instance_argument</span> <span class="o">:=</span> <span class="n">arguments</span><span class="p">[</span><span class="n">specie</span><span class="p">]),</span> <span class="n">Symbol</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">instance_argument</span>
            <span class="k">for</span> <span class="n">specie</span> <span class="ow">in</span> <span class="n">arguments</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instance_arguments</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_child</span>
        <span class="k">return</span> <span class="n">new_child</span></div>
    
<div class="viewcode-block" id="Parent.getChildren"><a class="viewcode-back" href="../Function.html#Function.Parent.getChildren">[docs]</a>    <span class="k">def</span> <span class="nf">getChildren</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Function</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Function</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get children functions in order added</span>
<span class="sd">        __Recursion Base__</span>
<span class="sd">            return all children: names [None]</span>

<span class="sd">        :param self: parent to retrieve child(s) from</span>
<span class="sd">        :param names: name(s) of child(s) to retrieve from parent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getModel</span><span class="p">()</span><span class="o">.</span><span class="n">getFunctions</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">children</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">getChildren</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildren</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getChildrenNames</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecursiveTypeError</span><span class="p">(</span><span class="n">names</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Parent.getChildrenNames"><a class="viewcode-back" href="../Function.html#Function.Parent.getChildrenNames">[docs]</a>    <span class="k">def</span> <span class="nf">getChildrenNames</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get names of stored parents in order added</span>
<span class="sd">        __Recursion Base__</span>
<span class="sd">            retrieve name of single parent: functions [Function]</span>
<span class="sd">            retrieve names of all parents: functions [None]</span>

<span class="sd">        :param self: parent to retrieve child name(s) from</span>
<span class="sd">        :param functions: function(s) to retrieve name(s) from parent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instance_arguments</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>
    
<div class="viewcode-block" id="Parent.getInstanceArgumentSpecies"><a class="viewcode-back" href="../Function.html#Function.Parent.getInstanceArgumentSpecies">[docs]</a>    <span class="k">def</span> <span class="nf">getInstanceArgumentSpecies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get all possible species of instance arguments</span>

<span class="sd">        :param self: parent to retrieve instance-argument species from</span>
<span class="sd">        :param name: name of child to retrieve instance-argument species for</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance_arguments</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="Parent.getInstanceArguments"><a class="viewcode-back" href="../Function.html#Function.Parent.getInstanceArguments">[docs]</a>    <span class="k">def</span> <span class="nf">getInstanceArguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">specie</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get instance arguments of given species for each function associated with given names</span>
<span class="sd">        __Recursion Base__</span>
<span class="sd">            return all instance arguments of given specie: specie [None] and names [None]</span>

<span class="sd">        :param self: parent to retrieve instance arguments from</span>
<span class="sd">        :param specie: name of instance-argument species to retrieve from parent</span>
<span class="sd">        :param name: name of child function to retrieve instance arguments for</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">specie</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance_arguments</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">specie</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">specie</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance_arguments</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;specie must be str&quot;</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="Child"><a class="viewcode-back" href="../Function.html#Function.Child">[docs]</a><span class="k">class</span> <span class="nc">Child</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    __Purpose__</span>
<span class="sd">        Properties for Function related to being a child function to another function</span>
<span class="sd">    __Attributes__</span>
<span class="sd">        parents [list of Function]: collection of parents associated with function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>
    
<div class="viewcode-block" id="Child.getParents"><a class="viewcode-back" href="../Function.html#Function.Child.getParents">[docs]</a>    <span class="k">def</span> <span class="nf">getParents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Function</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Function</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get parent functions in order added</span>
<span class="sd">        __Recursion Base__</span>
<span class="sd">            return all parents: names [None]</span>

<span class="sd">        :param self: child to retrieve parent(s) from</span>
<span class="sd">        :param names: name(s) of parent(s) to retrieve from child</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getModel</span><span class="p">()</span><span class="o">.</span><span class="n">getFunctions</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">parents</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">getParents</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getParents</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getParentNames</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecursiveTypeError</span><span class="p">(</span><span class="n">names</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Child.getParentNames"><a class="viewcode-back" href="../Function.html#Function.Child.getParentNames">[docs]</a>    <span class="k">def</span> <span class="nf">getParentNames</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get names of stored parents in order added</span>
<span class="sd">        __Recursion Base__</span>
<span class="sd">            retrieve name of single parent: functions [Function]</span>
<span class="sd">            retrieve names of all parents: functions [None]</span>

<span class="sd">        :param self: child to retrieve parent name(s) from</span>
<span class="sd">        :param functions: parent(s) to retrieve name(s) from child</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">function</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getModel</span><span class="p">()</span><span class="o">.</span><span class="n">getFunctions</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">function</span><span class="o">.</span><span class="n">getChildrenNames</span><span class="p">()</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">parents</span></div></div>

<div class="viewcode-block" id="Function"><a class="viewcode-back" href="../Function.html#Function.Function">[docs]</a><span class="k">class</span> <span class="nc">Function</span><span class="p">(</span><span class="n">Child</span><span class="p">,</span> <span class="n">Parent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    __Purpose__</span>
<span class="sd">        Object to store core information about a function</span>
<span class="sd">    __Attributes__</span>
<span class="sd">        name [str]: name of function</span>
<span class="sd">        variables [list of sympy.Symbol]: collection of variables explicitly included in function form</span>
<span class="sd">        parameters [list of sympy.Symbol]: collection of parameters explicitly included in function form</span>
<span class="sd">        model [Model]: model to associated with function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">variables</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">parameters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">children</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">model</span><span class="p">:</span> <span class="n">Model</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addVariables</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addParameters</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
        
        <span class="n">Parent</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
        <span class="n">Child</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setModel</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
    
<div class="viewcode-block" id="Function.getName"><a class="viewcode-back" href="../Function.html#Function.Function.getName">[docs]</a>    <span class="k">def</span> <span class="nf">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get name of function</span>

<span class="sd">        :param self: `~Function.Function` to retrieve name of</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span></div>
    
<div class="viewcode-block" id="Function.getSymbol"><a class="viewcode-back" href="../Function.html#Function.Function.getSymbol">[docs]</a>    <span class="k">def</span> <span class="nf">getSymbol</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Symbol</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get symbolic variable of function</span>

<span class="sd">        :param self: `~Function.Function` to retrieve symbolic variable of</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Symbol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">())</span></div>
    
<div class="viewcode-block" id="Function.addVariables"><a class="viewcode-back" href="../Function.html#Function.Function.addVariables">[docs]</a>    <span class="k">def</span> <span class="nf">addVariables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Add variable to function</span>

<span class="sd">        :param self: `~Function.Function` to add variable(s) to</span>
<span class="sd">        :param variables: variable(s) to add to function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;variable must be sympy.Symbol&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addVariables</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">variables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecursiveTypeError</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Function.addParameters"><a class="viewcode-back" href="../Function.html#Function.Function.addParameters">[docs]</a>    <span class="k">def</span> <span class="nf">addParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Set parameters attribute as list</span>

<span class="sd">        :param self: :class:`~Function.Function` to add parameter(s) to</span>
<span class="sd">        :param parameters: parameter(s) to add to function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;parameter must be sympy.Symbol&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addParameters</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecursiveTypeError</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Function.setModel"><a class="viewcode-back" href="../Function.html#Function.Function.setModel">[docs]</a>    <span class="k">def</span> <span class="nf">setModel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">Model</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set model for function.</span>
<span class="sd">        Add function to model if not already in done.</span>

<span class="sd">        :param self: :class:`~Function.Function` to set model with</span>
<span class="sd">        :param model: new model to associated with function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">Model</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">getFunctions</span><span class="p">():</span>
                <span class="n">model</span><span class="o">.</span><span class="n">addFunctions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;model input must be Model&quot;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Function.getModel"><a class="viewcode-back" href="../Function.html#Function.Function.getModel">[docs]</a>    <span class="k">def</span> <span class="nf">getModel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Model</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get model that function is stored within.</span>

<span class="sd">        :param self: :class:`~Function.Function` to retrieve model of</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span></div></div>

<div class="viewcode-block" id="Derivative"><a class="viewcode-back" href="../Function.html#Function.Derivative">[docs]</a><span class="k">class</span> <span class="nc">Derivative</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    __Purpose__</span>
<span class="sd">        Properties relating to function being a time derivative</span>
<span class="sd">    __Attributes__</span>
<span class="sd">        variable [sympy.Symbol]: variable that derivative is derivative of</span>
<span class="sd">        time_evolution_type [str]: time-evolution type of derivative (e.g. &quot;Temporal&quot;, &quot;Equilibrium&quot;, &quot;Constant&quot;)</span>
<span class="sd">        initial_condition [float]: initial condition value for associated variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">:</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">time_evolution_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Temporal&quot;</span><span class="p">,</span> <span class="n">initial_condition</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         __Inputs__</span>
<span class="sd">            variable [sympy.Symbol, str]: variable that derivative is a derivative of</span>
<span class="sd">            time_evolution_type [str]: time-evolution type of derivative (e.g. &quot;Temporal&quot;, &quot;Equilibrium&quot;, &quot;Constant&quot;)</span>
<span class="sd">            initial_condition [float]: initial value of variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setVariable</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_evolution_type</span> <span class="o">=</span> <span class="n">time_evolution_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setTimeEvolutionType</span><span class="p">(</span><span class="n">time_evolution_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_condition</span> <span class="o">=</span> <span class="n">initial_condition</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setInitialCondition</span><span class="p">(</span><span class="n">initial_condition</span><span class="p">)</span>
    
<div class="viewcode-block" id="Derivative.getVariable"><a class="viewcode-back" href="../Function.html#Function.Derivative.getVariable">[docs]</a>    <span class="k">def</span> <span class="nf">getVariable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get variable that derivative is derivative of.</span>

<span class="sd">        :param self: :class:`~Function.Derivative` to retreive variable from</span>
<span class="sd">        :param return_type: class type of output.</span>
<span class="sd">            Must be either sympy.Symbol or str.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">return_type</span> <span class="o">==</span> <span class="n">Symbol</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
        <span class="k">elif</span> <span class="n">return_type</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;return_type must be sp.Symbol or str&quot;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Derivative.setVariable"><a class="viewcode-back" href="../Function.html#Function.Derivative.setVariable">[docs]</a>    <span class="k">def</span> <span class="nf">setVariable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set variable associated with derivative.</span>
<span class="sd">        </span>
<span class="sd">        :param self: :class:`~Function.Derivative` associated with variable</span>
<span class="sd">        :param variable: variable to associated with derivative</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setVariable</span><span class="p">(</span><span class="n">Symbol</span><span class="p">(</span><span class="n">variable</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">=</span> <span class="n">variable</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;variable input must be str of sympy.Symbol&quot;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Derivative.getTimeEvolutionType"><a class="viewcode-back" href="../Function.html#Function.Derivative.getTimeEvolutionType">[docs]</a>    <span class="k">def</span> <span class="nf">getTimeEvolutionType</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get time-evolution type of variable associated with derivative.</span>

<span class="sd">        :param self: :class:`~Function.Derivative` to retrieve time-evolution type from</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_evolution_type</span></div>
    
<div class="viewcode-block" id="Derivative.setTimeEvolutionType"><a class="viewcode-back" href="../Function.html#Function.Derivative.setTimeEvolutionType">[docs]</a>    <span class="k">def</span> <span class="nf">setTimeEvolutionType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_evolution_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set time-evolution type for variable.</span>

<span class="sd">        :param self: :class:`~Function.Derivative` to set time-evolution type for</span>
<span class="sd">        :param time_evolution_type: time-evolution type to set for variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_evolution_type</span> <span class="o">=</span> <span class="n">time_evolution_type</span></div>
    
<div class="viewcode-block" id="Derivative.getInitialCondition"><a class="viewcode-back" href="../Function.html#Function.Derivative.getInitialCondition">[docs]</a>    <span class="k">def</span> <span class="nf">getInitialCondition</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get initial numerical condition for variable associated with derivative.</span>

<span class="sd">        :param self: :class:`~Function.Derivative` to retrieve initial condition from</span>
<span class="sd">        :returns: Initial value float if value is provided.</span>
<span class="sd">            &quot;Equilibrium&quot; if variable begins in equilibrium with respect to other variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getTimeEvolutionType</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;Equilibrium&quot;</span><span class="p">:</span>
            <span class="n">initial_condition</span> <span class="o">=</span> <span class="s2">&quot;Equilibrium&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">initial_condition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_condition</span>
        <span class="k">return</span> <span class="n">initial_condition</span></div>
    
<div class="viewcode-block" id="Derivative.setInitialCondition"><a class="viewcode-back" href="../Function.html#Function.Derivative.setInitialCondition">[docs]</a>    <span class="k">def</span> <span class="nf">setInitialCondition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set initial condition or value for variable.</span>

<span class="sd">        :param self: :class:`~Function.Derivative` to set initial condition for</span>
<span class="sd">        :param value: initial condition to set for variable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_condition</span> <span class="o">=</span> <span class="n">value</span></div></div>

<div class="viewcode-block" id="Dependent"><a class="viewcode-back" href="../Function.html#Function.Dependent">[docs]</a><span class="k">class</span> <span class="nc">Dependent</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    __Purpose__</span>
<span class="sd">        Store properties for a function that requires input from another function</span>
<span class="sd">    __Attributes__</span>
<span class="sd">        arguments [dict of list of sympy.Symbol]: arguments to be substituted into from another function</span>
<span class="sd">            keys [str] are species of argument (e.g. &quot;variables&quot;, &quot;parameters&quot;, &quot;functions&quot;)</span>
<span class="sd">            values [sympy.Symbol] are symbolic general arguments</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arguments</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">general_arguments</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setGeneralArguments</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
    
<div class="viewcode-block" id="Dependent.setGeneralArguments"><a class="viewcode-back" href="../Function.html#Function.Dependent.setGeneralArguments">[docs]</a>    <span class="k">def</span> <span class="nf">setGeneralArguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arguments</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]],</span> <span class="n">species</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Set receiver_arguments attribute as list or dict</span>
<span class="sd">        __Inputs__</span>
<span class="sd">            arguments [sympy.Symbol, list of sympy.Symbol, dict of list of sympy.Symbol]: contains information on how to set attribute</span>
<span class="sd">                sympy.Symbol, list of sympy.Symbol:</span>
<span class="sd">                    sets species [str] as key for attribute, single symbol in arguments as value</span>
<span class="sd">                    species must be given</span>
<span class="sd">                dict of list of sympy.Symbol:</span>
<span class="sd">                    key [str] is species type for argument</span>
<span class="sd">                    values [sympy.Symbol, list of sympy.Symbol] are arguments associated with species</span>
<span class="sd">            species [str]: species to associated with given arguments</span>
<span class="sd">        __Recursion Base__</span>
<span class="sd">            Set attribute for single species: arguments [sympy.Symbol, list of sympy.Symbol] and species [str]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arguments</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">general_arguments</span><span class="p">[</span><span class="n">species</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">arguments</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arguments</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">argument</span> <span class="ow">in</span> <span class="n">arguments</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;argument must be sympy.Symbol&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">general_arguments</span><span class="p">[</span><span class="n">species</span><span class="p">]</span> <span class="o">=</span> <span class="n">arguments</span>
            <span class="k">elif</span> <span class="n">arguments</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">general_arguments</span><span class="p">[</span><span class="n">species</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">RecursiveTypeError</span><span class="p">(</span><span class="n">arguments</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">species</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arguments</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">specie</span><span class="p">,</span> <span class="n">argument</span> <span class="ow">in</span> <span class="n">arguments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">setGeneralArguments</span><span class="p">(</span><span class="n">argument</span><span class="p">,</span> <span class="n">specie</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;arguments input must be dict when species input is None&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;species input must be str&quot;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Dependent.getGeneralSpecies"><a class="viewcode-back" href="../Function.html#Function.Dependent.getGeneralSpecies">[docs]</a>    <span class="k">def</span> <span class="nf">getGeneralSpecies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nested</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get species of general arguments that the dependent functions requires</span>
<span class="sd">        __Inputs__</span>
<span class="sd">            nested [bool]: set True to include species from children (implicit); set False to only include self species (explicit)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">species</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">general_arguments</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">nested</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildren</span><span class="p">():</span>
                <span class="n">child_species</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">getGeneralSpecies</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child_species</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">species</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child_species</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child_species</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">species</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">child_species</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child_species</span><span class="p">,</span> <span class="n">KeysView</span><span class="p">):</span>
                    <span class="n">species</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">child_species</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;species for </span><span class="si">{</span><span class="n">child</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2"> must be str, list, or dict_keys&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">unique</span><span class="p">(</span><span class="n">species</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Dependent.getGeneralArguments"><a class="viewcode-back" href="../Function.html#Function.Dependent.getGeneralArguments">[docs]</a>    <span class="k">def</span> <span class="nf">getGeneralArguments</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">species</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">nested</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get general arguments of Dependent Function object</span>
<span class="sd">        __Inputs__</span>
<span class="sd">            species [str, list of str]: species of argument to get</span>
<span class="sd">            nested [bool]:</span>
<span class="sd">                True: includes general arguments of children functions</span>
<span class="sd">                False: includes general arguments explicitly of self function</span>
<span class="sd">        __Return__</span>
<span class="sd">            dict of list of sympy.Symbol: species [None, list of str]</span>
<span class="sd">                key is argument species</span>
<span class="sd">                value is list of sympy.Symbol general arguments</span>
<span class="sd">            list of sympy.Symbol: species [str]</span>
<span class="sd">        __Recursion Base__</span>
<span class="sd">            return arguments of single species: species [str] and nested [False]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nested</span><span class="p">:</span>
            <span class="n">general_arguments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getGeneralArguments</span><span class="p">(</span><span class="n">species</span><span class="o">=</span><span class="n">species</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildren</span><span class="p">():</span>
                <span class="n">child_general_arguments</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">getGeneralArguments</span><span class="p">(</span><span class="n">species</span><span class="o">=</span><span class="n">species</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child_general_arguments</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
                    <span class="n">general_arguments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child_general_arguments</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child_general_arguments</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">general_arguments</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">child_general_arguments</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">RecursiveTypeError</span><span class="p">(</span><span class="n">child_general_arguments</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">general_arguments</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">nested</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">general_species</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getGeneralSpecies</span><span class="p">(</span><span class="n">nested</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">species</span> <span class="ow">in</span> <span class="n">general_species</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">general_arguments</span><span class="p">[</span><span class="n">species</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">species</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">general_species</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">specie</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">getGeneralArguments</span><span class="p">(</span><span class="n">specie</span><span class="p">)</span> <span class="k">for</span> <span class="n">specie</span> <span class="ow">in</span> <span class="n">species</span><span class="p">}</span>
            <span class="k">elif</span> <span class="n">species</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">specie</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">getGeneralArguments</span><span class="p">(</span><span class="n">specie</span><span class="p">)</span> <span class="k">for</span> <span class="n">specie</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getGeneralSpecies</span><span class="p">()}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">RecursiveTypeError</span><span class="p">(</span><span class="n">species</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Dependent.getInstanceArgumentSubstitutions"><a class="viewcode-back" href="../Function.html#Function.Dependent.getInstanceArgumentSubstitutions">[docs]</a>    <span class="k">def</span> <span class="nf">getInstanceArgumentSubstitutions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="n">Function</span><span class="p">,</span> <span class="n">specie</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Expr</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get which instance arguments to substitute into general arguments</span>
<span class="sd">        __Inputs__</span>
<span class="sd">            parent [Parent]: parent function to retrieve instance arguments from</span>
<span class="sd">            specie [str]: species of argument to retrieve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">self_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getName</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">specie</span> <span class="o">==</span> <span class="s2">&quot;functions&quot;</span><span class="p">:</span>
            <span class="n">instance_function_symbols</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">getInstanceArguments</span><span class="p">(</span><span class="n">specie</span><span class="o">=</span><span class="n">specie</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">self_name</span><span class="p">)</span>
            <span class="n">instance_names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">instance_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">instance_name</span> <span class="ow">in</span> <span class="n">instance_function_symbols</span><span class="p">]</span>
            <span class="n">instance_functions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">instance_name</span> <span class="ow">in</span> <span class="n">instance_names</span><span class="p">:</span>
                <span class="n">sibling</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">getChildren</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">instance_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sibling</span><span class="p">,</span> <span class="n">Dependent</span><span class="p">):</span>
                    <span class="n">instance_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sibling</span><span class="o">.</span><span class="n">getInstanceArgumentFunction</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sibling</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>
                    <span class="n">instance_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sibling</span><span class="o">.</span><span class="n">getForm</span><span class="p">(</span><span class="n">generations</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sibling for </span><span class="si">{</span><span class="n">self_name</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2"> must be Function&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">instance_functions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">parent</span><span class="o">.</span><span class="n">getInstanceArguments</span><span class="p">(</span><span class="n">specie</span><span class="o">=</span><span class="n">specie</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">self_name</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Dependent.getArgumentSubstitutions"><a class="viewcode-back" href="../Function.html#Function.Dependent.getArgumentSubstitutions">[docs]</a>    <span class="k">def</span> <span class="nf">getArgumentSubstitutions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="n">Function</span><span class="p">,</span> <span class="n">specie</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Expr</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get substitutions for dependent, i.e. which instance argument to substitute into each general argument</span>
<span class="sd">        __Inputs__</span>
<span class="sd">            parent [Parent]: parent function to retrieve instance arguments from</span>
<span class="sd">            specie [str]: species of argument to retrieve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">general_arguments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getGeneralArguments</span><span class="p">(</span><span class="n">species</span><span class="o">=</span><span class="n">specie</span><span class="p">)</span>
        <span class="n">instance_arguments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getInstanceArgumentSubstitutions</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">specie</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">general_arguments</span><span class="p">,</span> <span class="n">instance_arguments</span><span class="p">))</span></div>
    
<div class="viewcode-block" id="Dependent.getInstanceArgumentFunction"><a class="viewcode-back" href="../Function.html#Function.Dependent.getInstanceArgumentFunction">[docs]</a>    <span class="k">def</span> <span class="nf">getInstanceArgumentFunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="n">Function</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get dependent function with instance arguments substituted into general arguments</span>
<span class="sd">        __Inputs__</span>
<span class="sd">            parent [Parent]: parent function to retrieve instance arguments from</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">species</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getGeneralSpecies</span><span class="p">()</span>
        <span class="n">function_sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getForm</span><span class="p">(</span><span class="n">generations</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">specie</span> <span class="ow">in</span> <span class="n">species</span><span class="p">:</span>
            <span class="n">substitutions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getArgumentSubstitutions</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">specie</span><span class="p">)</span>
            <span class="n">function_sub</span> <span class="o">=</span> <span class="n">function_sub</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">substitutions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">function_sub</span></div></div>

<div class="viewcode-block" id="Independent"><a class="viewcode-back" href="../Function.html#Function.Independent">[docs]</a><span class="k">class</span> <span class="nc">Independent</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    __Purpose__</span>
<span class="sd">        Store properties for a function that does not require input from another function</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="k">pass</span></div>

<div class="viewcode-block" id="Piecewise"><a class="viewcode-back" href="../Function.html#Function.Piecewise">[docs]</a><span class="k">class</span> <span class="nc">Piecewise</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    __Purpose__</span>
<span class="sd">        Store information pertaining to piecewise function</span>
<span class="sd">    __Attributes__</span>
<span class="sd">        functions [list of Function]: function pieces making up piecewise function</span>
<span class="sd">        conditions [bool]: conditions under which each function piece is used</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">functions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Function</span><span class="p">],</span> <span class="n">conditions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">functions</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">conditions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;each function must have exactly one corresponding condition&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span> <span class="o">=</span> <span class="n">functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conditions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">eval</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="k">for</span> <span class="n">condition</span> <span class="ow">in</span> <span class="n">conditions</span><span class="p">]</span>  <span class="c1"># eval() to convert str to bool</span>
    
<div class="viewcode-block" id="Piecewise.getConditions"><a class="viewcode-back" href="../Function.html#Function.Piecewise.getConditions">[docs]</a>    <span class="k">def</span> <span class="nf">getConditions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get conditions that determine which function piece to use</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">conditions</span></div>
    
<div class="viewcode-block" id="Piecewise.getPieces"><a class="viewcode-back" href="../Function.html#Function.Piecewise.getPieces">[docs]</a>    <span class="k">def</span> <span class="nf">getPieces</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Function</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get Function objects constituting Piecewise object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span></div>
    
<div class="viewcode-block" id="Piecewise.getPieceCount"><a class="viewcode-back" href="../Function.html#Function.Piecewise.getPieceCount">[docs]</a>    <span class="k">def</span> <span class="nf">getPieceCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get number of pieces constituting piecewise function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Piecewise.getForm"><a class="viewcode-back" href="../Function.html#Function.Piecewise.getForm">[docs]</a>    <span class="k">def</span> <span class="nf">getForm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">generations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">spPiecewise</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get symbolic piecewise expression for self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">functions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPieces</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">generations</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">function</span><span class="o">.</span><span class="n">getForm</span><span class="p">(</span><span class="n">generations</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">generations</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">function</span><span class="o">.</span><span class="n">getForm</span><span class="p">(</span><span class="n">generations</span><span class="o">=</span><span class="n">generations</span><span class="p">)</span> <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;generations must be &#39;all&#39; or some integer greater than or equal to 0&quot;</span><span class="p">)</span>
        <span class="n">conditions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getConditions</span><span class="p">()</span>
        <span class="n">exprconds</span> <span class="o">=</span> <span class="p">[(</span><span class="n">pieces</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">conditions</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getPieceCount</span><span class="p">())]</span>
        <span class="k">return</span> <span class="n">spPiecewise</span><span class="p">(</span><span class="o">*</span><span class="n">exprconds</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Piecewise.getVariables"><a class="viewcode-back" href="../Function.html#Function.Piecewise.getVariables">[docs]</a>    <span class="k">def</span> <span class="nf">getVariables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nested</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get unique list of variables in function, including pieces</span>
<span class="sd">        __Inputs__</span>
<span class="sd">            nested [bool]: set True to include variables from children (implicit), False to only include self variables (explicit)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span>
        <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPieces</span><span class="p">():</span>
            <span class="n">variables</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">getVariables</span><span class="p">(</span><span class="n">nested</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">unique</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Piecewise.getParameters"><a class="viewcode-back" href="../Function.html#Function.Piecewise.getParameters">[docs]</a>    <span class="k">def</span> <span class="nf">getParameters</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">nested</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">return_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Symbol</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get unique list of parameters in function.</span>
<span class="sd">        </span>
<span class="sd">        :param self: :class:`~Function.NonPiecewise` to retrieve parameters from</span>
<span class="sd">        :param nested: set True to include parameters from children (implicit).</span>
<span class="sd">            Set False to only include self parameters (explicit).</span>
<span class="sd">        :param return_type: class type to return elements in list output as</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span>
        <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPieces</span><span class="p">():</span>
            <span class="n">parameters</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">getParameters</span><span class="p">(</span><span class="n">nested</span><span class="o">=</span><span class="n">nested</span><span class="p">))</span>
        <span class="n">unique_parameters</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">return_type</span> <span class="o">==</span> <span class="n">Symbol</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">unique_parameters</span>
        <span class="k">elif</span> <span class="n">return_type</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span> <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">unique_parameters</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;return_type must be Symbol or str&quot;</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="NonPiecewise"><a class="viewcode-back" href="../Function.html#Function.NonPiecewise">[docs]</a><span class="k">class</span> <span class="nc">NonPiecewise</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    __Purpose__</span>
<span class="sd">        Store information pertaining to nonpiecewise (standard) function</span>
<span class="sd">    __Attributes__</span>
<span class="sd">        functions [list of Function]: function form of object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expression</span> <span class="o">=</span> <span class="n">expression</span>
    
<div class="viewcode-block" id="NonPiecewise.getForm"><a class="viewcode-back" href="../Function.html#Function.NonPiecewise.getForm">[docs]</a>    <span class="k">def</span> <span class="nf">getForm</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="n">Function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">substitute_dependents</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">generations</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get functional form of Function object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Dependent</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getInstanceArgumentFunction</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildren</span><span class="p">():</span>
            <span class="n">child_symbol</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">getSymbol</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Dependent</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">substitute_dependents</span><span class="p">:</span>
                    <span class="n">child_expression</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">getForm</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">child_expression</span> <span class="o">=</span> <span class="n">child_symbol</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Independent</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">generations</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
                    <span class="n">child_expression</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">getForm</span><span class="p">(</span>
                        <span class="n">substitute_dependents</span><span class="o">=</span><span class="n">substitute_dependents</span><span class="p">,</span> <span class="n">generations</span><span class="o">=</span><span class="n">generations</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">generations</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">child_expression</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">getForm</span><span class="p">(</span>
                        <span class="n">substitute_dependents</span><span class="o">=</span><span class="n">substitute_dependents</span><span class="p">,</span> <span class="n">generations</span><span class="o">=</span><span class="n">generations</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">generations</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">child_expression</span> <span class="o">=</span> <span class="n">child_symbol</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;generations must be &#39;all&#39; or some integer greater than or equal to 0&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;child must be of type Dependent xor Independent&quot;</span><span class="p">)</span>
            <span class="n">expression</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">child_symbol</span><span class="p">,</span> <span class="n">child_expression</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expression</span></div>
    
<div class="viewcode-block" id="NonPiecewise.getVariables"><a class="viewcode-back" href="../Function.html#Function.NonPiecewise.getVariables">[docs]</a>    <span class="k">def</span> <span class="nf">getVariables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nested</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get unique list of variables in function</span>
<span class="sd">        __Inputs__</span>
<span class="sd">            nested [bool]: set True to include variables from children (implicit), False to only include self variables (explicit)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span>
        <span class="k">if</span> <span class="n">nested</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildren</span><span class="p">():</span>
                <span class="n">child_variables</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">getVariables</span><span class="p">(</span><span class="n">nested</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child_variables</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
                    <span class="n">variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child_variables</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child_variables</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">variables</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">child_variables</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">RecursiveTypeError</span><span class="p">(</span><span class="n">child_variables</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">unique</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="NonPiecewise.getParameters"><a class="viewcode-back" href="../Function.html#Function.NonPiecewise.getParameters">[docs]</a>    <span class="k">def</span> <span class="nf">getParameters</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">nested</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">return_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Symbol</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get unique list of parameters in function.</span>
<span class="sd">        </span>
<span class="sd">        :param self: :class:`~Function.NonPiecewise` to retrieve parameters from</span>
<span class="sd">        :param nested: set True to include parameters from children (implicit).</span>
<span class="sd">            Set False to only include self parameters (explicit).</span>
<span class="sd">        :param return_type: class type to return elements in list output as</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span>
        <span class="k">if</span> <span class="n">nested</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getChildren</span><span class="p">():</span>
                <span class="n">child_parameters</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">getParameters</span><span class="p">(</span><span class="n">nested</span><span class="o">=</span><span class="n">nested</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="n">return_type</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child_parameters</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
                    <span class="n">parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child_parameters</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child_parameters</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">parameters</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">child_parameters</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">RecursiveTypeError</span><span class="p">(</span><span class="n">child_parameters</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)</span>
        <span class="n">unique_parameters</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">return_type</span> <span class="o">==</span> <span class="n">Symbol</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">unique_parameters</span>
        <span class="k">elif</span> <span class="n">return_type</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span> <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">unique_parameters</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;return_type must be Symbol or str&quot;</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="FunctionMaster"><a class="viewcode-back" href="../Function.html#Function.FunctionMaster">[docs]</a><span class="k">def</span> <span class="nf">FunctionMaster</span><span class="p">(</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">function</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Expr</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Function</span><span class="p">]],</span>
        <span class="n">inheritance</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Derivative</span><span class="p">,</span> <span class="n">Dependent</span><span class="p">,</span> <span class="n">Independent</span><span class="p">,</span> <span class="n">Piecewise</span><span class="p">,</span> <span class="n">NonPiecewise</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">(),</span>
        <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Function</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    __Purpose__</span>
<span class="sd">        Get Function object with desired properties</span>
<span class="sd">    __Inputs__</span>
<span class="sd">        name [str]: name associated with function</span>
<span class="sd">        function [sympy.Expr, list of Function]:</span>
<span class="sd">            sympy.Expr: form of function (e.g. x**2 in f(x)=x**2) for non-piecewise function</span>
<span class="sd">            list of Function: collection of function pieces for piecewise function</span>
<span class="sd">        inheritance [tuple of classes]: classes for function to inherit</span>
<span class="sd">            Dependent: inherit if function requires input (e.g. variable or parameter input)</span>
<span class="sd">            Derivative: inherit if function should be included in ODE of model</span>
<span class="sd">            Piecewise: inherit if function is piecewise</span>
<span class="sd">            NonPiecewise: inherit if function is non-piecewise</span>
<span class="sd">        **kwargs [dict]: arguments to be given to each inherited class&#39;s __init__</span>
<span class="sd">            e.g. kwargs[&quot;Dependent&quot;] holds arguments for Dependent __init__ if function inherits Dependent class</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">class</span> <span class="nc">FunctionCore</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="o">*</span><span class="n">inheritance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Object to store various information about a function</span>
<span class="sd">            Allows Function object to dynamically inherit necessary classes</span>

<span class="sd">        .. seealso:: Function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                <span class="n">function</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Expr</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Function</span><span class="p">]],</span>
                <span class="n">inheritance</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Derivative</span><span class="p">,</span> <span class="n">Dependent</span><span class="p">,</span> <span class="n">Independent</span><span class="p">,</span> <span class="n">Piecewise</span><span class="p">,</span> <span class="n">NonPiecewise</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">(),</span>
                <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            __Purpose__</span>
<span class="sd">                Instantiate Function object with necessary class inheritance</span>
<span class="sd">            __Inputs__</span>
<span class="sd">                cf. FunctionMaster</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">Derivative</span> <span class="ow">in</span> <span class="n">inheritance</span><span class="p">:</span>
                <span class="n">Derivative</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;Derivative&quot;</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="n">Dependent</span> <span class="ow">in</span> <span class="n">inheritance</span><span class="p">:</span>
                <span class="n">Dependent</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;Dependent&quot;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">Independent</span> <span class="ow">in</span> <span class="n">inheritance</span><span class="p">:</span>
                <span class="n">Independent</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Function must inherit either Dependent or Independent&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">Piecewise</span> <span class="ow">in</span> <span class="n">inheritance</span><span class="p">:</span>
                <span class="n">Piecewise</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;Piecewise&quot;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">NonPiecewise</span> <span class="ow">in</span> <span class="n">inheritance</span><span class="p">:</span>
                <span class="n">NonPiecewise</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Function must inherit either Piecewise of NonPiecewise&quot;</span><span class="p">)</span>
            
            <span class="n">Function</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">FunctionCore</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">inheritance</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="getFunctionInfo"><a class="viewcode-back" href="../Function.html#Function.getFunctionInfo">[docs]</a><span class="k">def</span> <span class="nf">getFunctionInfo</span><span class="p">(</span><span class="n">info</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]]],</span> <span class="n">model</span><span class="p">:</span> <span class="n">Model</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span>\
        <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    __Purpose__</span>
<span class="sd">        Get properly formatted dictionary of information to create Function object</span>
<span class="sd">    __Inputs__</span>
<span class="sd">        info [dict]: collection of information to properly create Function object</span>
<span class="sd">            {&quot;properties&quot;: [list of str],</span>
<span class="sd">            &quot;variables&quot;: [str, list of str],</span>
<span class="sd">            &quot;parameters&quot;: [str, list of str],</span>
<span class="sd">            &quot;form&quot;: [str],</span>
<span class="sd">            &quot;children&quot;:</span>
<span class="sd">                [{child_name:</span>
<span class="sd">                    {&quot;variables&quot;: [str, list of str],</span>
<span class="sd">                    &quot;parameters&quot;: [str, list of str]}</span>
<span class="sd">                }]</span>
<span class="sd">            &quot;arguments&quot;:</span>
<span class="sd">                &quot;variables&quot;: [str, list of str]</span>
<span class="sd">                &quot;parameters&quot;: [str, list of str]</span>
<span class="sd">                &quot;functions&quot;: [str, list of str]</span>
<span class="sd">            &quot;variable&quot;: [str]</span>
<span class="sd">            }</span>
<span class="sd">        model [Model]: model to associated Function object with</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">getVariables</span><span class="p">(</span><span class="n">info</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get variable for function</span>
<span class="sd">            Create symbolic variable of each parameter</span>
<span class="sd">        __Inputs__</span>
<span class="sd">            info [dict]: contains information and properties of function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">var</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;variables&quot;</span><span class="p">])</span>
    
    <span class="k">def</span> <span class="nf">getParameters</span><span class="p">(</span><span class="n">info</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get parameters for function</span>
<span class="sd">            Create symbolic variable of each parameter</span>
<span class="sd">        __Inputs__</span>
<span class="sd">            info [dict]: contains information and properties of function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">var</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;parameters&quot;</span><span class="p">])</span>
    
    <span class="k">def</span> <span class="nf">getProperties</span><span class="p">(</span><span class="n">info</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get collection of properties to give function (e.g. piecewise, dependent)</span>
<span class="sd">        __Inputs__</span>
<span class="sd">            info [dict]: contains information and properties of function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">]</span>
    
    <span class="k">def</span> <span class="nf">getArguments</span><span class="p">(</span><span class="n">info</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get input arguments into function</span>
<span class="sd">            Create symbolic variable of each argument</span>
<span class="sd">        __Inputs__</span>
<span class="sd">            info [dict]: contains information and properties of function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arguments</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;arguments&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">var</span><span class="p">(</span><span class="n">arguments</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">arguments</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
    
    <span class="k">def</span> <span class="nf">getVariable</span><span class="p">(</span><span class="n">info</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Symbol</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get associated variable for derivative</span>
<span class="sd">        __Inputs__</span>
<span class="sd">            info [dict]: contains information and properties of function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;variable&quot;</span><span class="p">])</span>
    
    <span class="k">def</span> <span class="nf">getChildren</span><span class="p">(</span><span class="n">model</span><span class="p">:</span> <span class="n">Model</span><span class="p">,</span> <span class="n">info</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">Function</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]]]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        __Purpose__</span>
<span class="sd">            Get nested functions (a.k.a. children functions), composite functions (e.g. g(x) in f(g(x)))</span>
<span class="sd">            Get associated arguments to input into each child function, keeping track of argument type (e.g. parameter, variable)</span>
<span class="sd">            Create symbolic variable of each argument</span>
<span class="sd">        __Inputs__</span>
<span class="sd">            model [Model]: model to retrieve child Function object from</span>
<span class="sd">            children_info [dict]:</span>
<span class="sd">                keys [str] are name of child function</span>
<span class="sd">                values [dict, None] contain instance argument(s) into child function</span>
<span class="sd">                    keys [str] are species of argument (e.g. &quot;variables&quot;,&quot;parameters&quot;,&quot;functions&quot;)</span>
<span class="sd">                    values [str, list of str] are argument names</span>
<span class="sd">        __Return__</span>
<span class="sd">            dict</span>
<span class="sd">                keys [str] are name of child function</span>
<span class="sd">                values contain information about child function in relation to parent</span>
<span class="sd">                    keys: values</span>
<span class="sd">                        argument_type [str]: arguments [sympy.Symbol, list of sympy.Symbol] of given argument_type to input to child function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">children_info</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;children&quot;</span><span class="p">]</span>
        <span class="n">children_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">children_info</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">var</span><span class="p">(</span><span class="n">children_names</span><span class="p">)</span>
        
        <span class="n">children_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">child_name</span> <span class="ow">in</span> <span class="n">children_names</span><span class="p">:</span>
            <span class="n">child_info</span> <span class="o">=</span> <span class="n">children_info</span><span class="p">[</span><span class="n">child_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">child_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">children_dict</span><span class="p">[</span><span class="n">child_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">argument_type</span><span class="p">:</span> <span class="n">var</span><span class="p">(</span><span class="n">child_info</span><span class="p">[</span><span class="n">argument_type</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">argument_type</span> <span class="ow">in</span> <span class="n">child_info</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="p">}</span>
            <span class="k">elif</span> <span class="n">child_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">children_dict</span><span class="p">[</span><span class="n">child_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="n">children_dict</span>
    
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;model&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span>
    
    <span class="n">info_keys</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="k">if</span> <span class="s2">&quot;variables&quot;</span> <span class="ow">in</span> <span class="n">info_keys</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;variables&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">getVariables</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;parameters&quot;</span> <span class="ow">in</span> <span class="n">info_keys</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;parameters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">getParameters</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;children&quot;</span> <span class="ow">in</span> <span class="n">info_keys</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;children&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">getChildren</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
    
    <span class="n">properties</span> <span class="o">=</span> <span class="n">getProperties</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">properties</span>
    <span class="k">if</span> <span class="s2">&quot;Dependent&quot;</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;Dependent&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;arguments&quot;</span><span class="p">:</span> <span class="n">getArguments</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="k">if</span> <span class="s2">&quot;Derivative&quot;</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;Derivative&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;variable&quot;</span><span class="p">:</span> <span class="n">getVariable</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="k">if</span> <span class="s2">&quot;Piecewise&quot;</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;Piecewise&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;conditions&quot;</span><span class="p">:</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;conditions&quot;</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="k">return</span> <span class="n">kwargs</span></div>

<div class="viewcode-block" id="generateFunctionsFromFile"><a class="viewcode-back" href="../Function.html#Function.generateFunctionsFromFile">[docs]</a><span class="k">def</span> <span class="nf">generateFunctionsFromFile</span><span class="p">(</span><span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Function</span><span class="p">]:</span>
    <span class="n">file</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="n">Loader</span><span class="o">=</span><span class="n">yaml</span><span class="o">.</span><span class="n">Loader</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">generateFunction</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">file</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span></div>

<div class="viewcode-block" id="getInheritance"><a class="viewcode-back" href="../Function.html#Function.getInheritance">[docs]</a><span class="k">def</span> <span class="nf">getInheritance</span><span class="p">(</span><span class="n">properties</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Function</span><span class="p">]]:</span>
    <span class="n">inheritance</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="s2">&quot;Derivative&quot;</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
        <span class="n">inheritance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Derivative</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="s2">&quot;Dependent&quot;</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
        <span class="n">inheritance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Dependent</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s2">&quot;Independent&quot;</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
        <span class="n">inheritance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Independent</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Function </span><span class="si">{</span><span class="n">name</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2"> must have either &#39;Dependent&#39; or &#39;Independent&#39; as property&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="s2">&quot;Piecewise&quot;</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
        <span class="n">inheritance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Piecewise</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s2">&quot;Piecewise&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
        <span class="n">inheritance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NonPiecewise</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">inheritance</span></div>

<div class="viewcode-block" id="generateFunction"><a class="viewcode-back" href="../Function.html#Function.generateFunction">[docs]</a><span class="k">def</span> <span class="nf">generateFunction</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">file</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span> <span class="n">model</span><span class="p">:</span> <span class="n">Model</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Function</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    __Purpose__</span>
<span class="sd">        Create Function object with desired...</span>
<span class="sd">            parent-child associations</span>
<span class="sd">            variable-parameter distinctions</span>
<span class="sd">            properties</span>

<span class="sd">    :param name: name of new function</span>
<span class="sd">    :param function: expression (non-piecewise) or collection of function-object pieces (piecewise) for new function object</span>
<span class="sd">    :param properties: collection of properties to give new function</span>
<span class="sd">    :param kwargs: see FunctionCore</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">file</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">getFunctionInfo</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">)</span>
    
    <span class="n">info_keys</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="k">if</span> <span class="s2">&quot;form&quot;</span> <span class="ow">in</span> <span class="n">info_keys</span><span class="p">:</span>
        <span class="n">form</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;form&quot;</span><span class="p">])</span>
    <span class="k">elif</span> <span class="s2">&quot;pieces&quot;</span> <span class="ow">in</span> <span class="n">info_keys</span><span class="p">:</span>
        <span class="n">form</span> <span class="o">=</span> <span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">getFunctions</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="n">piece_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">piece_name</span> <span class="ow">in</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;pieces&quot;</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;info from functions_yml file must contain either form or pieces&quot;</span><span class="p">)</span>
    
    <span class="n">inheritance</span> <span class="o">=</span> <span class="n">getInheritance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">FunctionMaster</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">form</span><span class="p">,</span> <span class="n">inheritance</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">inheritance</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="createModel"><a class="viewcode-back" href="../Function.html#Function.createModel">[docs]</a><span class="k">def</span> <span class="nf">createModel</span><span class="p">(</span><span class="n">function_ymls</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">parameters_yml</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Model</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    __Purpose__</span>
<span class="sd">        Create model from given YML files</span>
<span class="sd">    __Inputs__</span>
<span class="sd">        functions_yml [str]: name of YML file containing function/equation info</span>
<span class="sd">        parameters_yml [str]: name of YML file containing parameters info</span>

<span class="sd">    :param function_ymls: name of YML file containing information for function</span>
<span class="sd">    :param parameters_yml: name of YML file containing information about parameter values/units</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">()</span>
    <span class="n">model</span><span class="o">.</span><span class="n">loadParametersFromFile</span><span class="p">(</span><span class="n">parameters_yml</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">loadFunctionsFromFiles</span><span class="p">(</span><span class="n">function_ymls</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">model</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, Joseph Marcinik.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> and   using a custom <a href="https://github.com/LinxiFan/Stanford-theme">theme</a> based on <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'2021',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/clipboard.min.js"></script>
      <script type="text/javascript" src="../_static/copybutton.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>